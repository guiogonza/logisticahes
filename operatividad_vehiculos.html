<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Dashboard Operatividad Veh√≠culos</title>

  <!-- Librer√≠a para leer Excel en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- Plotly para gr√°ficas interactivas -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      background: #f4f5f7;
      color: #222;
    }
    header {
      background: linear-gradient(135deg, #1c4e80, #00a3cc);
      color: #fff;
      padding: 1.2rem 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    header .logo {
      height: 80px;
      width: auto;
      background: white;
      border-radius: 8px;
      padding: 8px;
    }
    header .header-text {
      flex: 1;
      text-align: center;
    }
    header h1 {
      margin: 0;
      font-size: 1.6rem;
    }
    header p {
      margin: 0.2rem 0 0;
      opacity: 0.9;
    }
    .container {
      padding: 1.5rem 2rem 2rem;
      max-width: 1400px;
      margin: 0 auto;
    }
    .card {
      background: #fff;
      border-radius: 12px;
      padding: 1rem 1.2rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      margin-bottom: 1rem;
    }
    #controls {
      display: grid;
      grid-template-columns: 1.5fr 1fr 1fr 1fr 1fr;
      gap: 1rem;
      align-items: flex-end;
    }
    label {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
      display: block;
    }
    input[type="file"],
    select,
    input[type="date"],
    button {
      width: 100%;
      padding: 0.4rem 0.6rem;
      border-radius: 8px;
      border: 1px solid #d0d7de;
      font-size: 0.9rem;
      box-sizing: border-box;
    }
    select[multiple] {
      height: 90px;
    }
    button {
      cursor: pointer;
      font-weight: 600;
      border: none;
      background: #1c4e80;
      color: #fff;
      transition: transform 0.05s ease, box-shadow 0.1s ease, background 0.15s ease;
    }
    button:hover {
      background: #163b61;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      transform: translateY(-1px);
    }
    button.secondary {
      background: #e1e4e8;
      color: #111;
      margin-top: 0.4rem;
    }
    button.secondary:hover {
      background: #d0d7de;
    }
    .filter-search {
      width: 100%;
      padding: 0.3rem 0.5rem;
      border-radius: 6px;
      border: 1px solid #d0d7de;
      font-size: 0.8rem;
      box-sizing: border-box;
      margin-bottom: 0.3rem;
    }
    .filter-search::placeholder {
      color: #999;
    }
    .date-picker-container {
      position: relative;
    }
    .date-input {
      width: 100%;
      padding: 0.4rem 0.6rem;
      border-radius: 8px;
      border: 1px solid #d0d7de;
      font-size: 0.85rem;
      box-sizing: border-box;
      cursor: pointer;
      background: white;
      margin-bottom: 0.3rem;
    }
    .date-input:hover {
      border-color: #1c4e80;
    }
    .date-popup {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      padding: 0.5rem;
      display: none;
    }
    .date-popup.active {
      display: block;
    }
    .date-popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #eee;
    }
    .date-popup-title {
      font-weight: 600;
      font-size: 0.85rem;
    }
    .date-popup-close {
      cursor: pointer;
      font-size: 1.2rem;
      color: #666;
    }
    .month-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.3rem;
      margin-bottom: 0.5rem;
    }
    .month-btn, .day-btn {
      padding: 0.4rem;
      border: 1px solid #e1e4e8;
      border-radius: 6px;
      background: #f6f8fa;
      cursor: pointer;
      font-size: 0.8rem;
      text-align: center;
      transition: all 0.1s;
    }
    .month-btn:hover, .day-btn:hover {
      background: #1c4e80;
      color: white;
      border-color: #1c4e80;
    }
    .month-btn.selected, .day-btn.selected {
      background: #1c4e80;
      color: white;
      border-color: #1c4e80;
    }
    .day-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 0.2rem;
    }
    .year-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.3rem;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e1e4e8;
    }
    .year-btn {
      padding: 0.4rem;
      border: 1px solid #e1e4e8;
      border-radius: 6px;
      background: #f6f8fa;
      cursor: pointer;
      font-size: 0.85rem;
      text-align: center;
      transition: all 0.1s;
      font-weight: 500;
    }
    .year-btn:hover {
      background: #1c4e80;
      color: white;
      border-color: #1c4e80;
    }
    .year-btn.selected {
      background: #1c4e80;
      color: white;
      border-color: #1c4e80;
    }
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 0.8rem;
      margin-top: 1rem;
    }
    .kpi {
      background: #fff;
      border-radius: 10px;
      padding: 0.8rem 0.9rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    }
    .kpi label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #555;
      margin-bottom: 0.15rem;
    }
    .kpi-value {
      font-size: 1.1rem;
      font-weight: 700;
    }
    .kpi-sub {
      font-size: 0.8rem;
      color: #777;
      margin-top: 0.15rem;
    }
    .charts-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 1rem;
      margin-top: 1rem;
    }
    .chart-card {
      background: #fff;
      border-radius: 12px;
      padding: 0.5rem 0.6rem 0.8rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    .chart-title {
      font-weight: 600;
      font-size: 0.95rem;
      margin: 0.1rem 0 0.2rem 0.2rem;
    }
    .chart {
      width: 100%;
      height: 340px;
    }
    .full-width-chart {
      margin-top: 1rem;
    }
    #status {
      font-size: 0.85rem;
      color: #555;
      margin-top: 0.4rem;
    }
    /* Tabla detalle */
    .table-container {
      margin-top: 1.2rem;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      padding: 0.8rem;
      max-height: 400px;
      overflow: auto;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.8rem;
    }
    th, td {
      border-bottom: 1px solid #e1e4e8;
      padding: 0.35rem 0.45rem;
      text-align: left;
      white-space: nowrap;
    }
    th {
      position: sticky;
      top: 0;
      background: #f6f8fa;
      z-index: 1;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s;
    }
    th:hover {
      background: #e1e4e8;
    }
    th .sort-icon {
      margin-left: 0.3rem;
      font-size: 0.7rem;
      color: #888;
    }
    th.sort-asc .sort-icon::after {
      content: '‚ñ≤';
      color: #1c4e80;
    }
    th.sort-desc .sort-icon::after {
      content: '‚ñº';
      color: #1c4e80;
    }
    th:not(.sort-asc):not(.sort-desc) .sort-icon::after {
      content: '‚áÖ';
    }
    tr:nth-child(even) td {
      background: #fafbfc;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.05rem 0.4rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      background: #e1ecf4;
      color: #0b4f79;
    }
    @media (max-width: 960px) {
      #controls {
        grid-template-columns: 1fr;
      }
      .kpi-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-text">
      <h1>Dashboard - Operatividad Veh√≠culos</h1>
      <p>Carga el archivo <strong>OPERATIVIDAD DIARIA.xlsx</strong> y explora las gr√°ficas y filtros.</p>
    </div>
  </header>

  <div class="container">

    <!-- Controles -->
    <div class="card">
      <div id="controls">
        <div>
          <div style="text-align: center; margin-bottom: 0.8rem;">
            <img src="img/logo.png" alt="HESEGO Ingenier√≠a S.A.S" style="height: 120px; width: auto;">
          </div>
          <label for="fileInput">Archivo Excel</label>
          <input type="file" id="fileInput" accept=".xlsx,.xls" />
          <div id="status"></div>
        </div>

        <div>
          <label for="sedeFilter">Sede (multi-selecci√≥n)</label>
          <input type="text" class="filter-search" id="sedeSearch" placeholder="Buscar sede..." oninput="filterSelect('sedeFilter', this.value)">
          <select id="sedeFilter" multiple></select>
          <button type="button" class="secondary" id="sedeFilterBtn" onclick="toggleSelectAll('sedeFilter', 'sedeFilterBtn')">Seleccionar todo</button>
        </div>

        <div>
          <label for="estadoFilter">Estado Veh√≠culo (multi)</label>
          <input type="text" class="filter-search" id="estadoSearch" placeholder="Buscar estado..." oninput="filterSelect('estadoFilter', this.value)">
          <select id="estadoFilter" multiple></select>
          <button type="button" class="secondary" id="estadoFilterBtn" onclick="toggleSelectAll('estadoFilter', 'estadoFilterBtn')">Seleccionar todo</button>
        </div>

        <div>
          <label for="placaFilter">Placa (multi-selecci√≥n)</label>
          <input type="text" class="filter-search" id="placaSearch" placeholder="Buscar placa..." oninput="filterSelect('placaFilter', this.value)">
          <select id="placaFilter" multiple></select>
          <button type="button" class="secondary" id="placaFilterBtn" onclick="toggleSelectAll('placaFilter', 'placaFilterBtn')">Seleccionar todo</button>
        </div>

        <div>
          <label>Rango de fechas</label>
          
          <div class="date-picker-container">
            <input type="text" class="date-input" id="startDateDisplay" placeholder="Desde..." readonly onclick="openDatePicker('start')">
            <div class="date-popup" id="startDatePopup">
              <div class="date-popup-header">
                <span class="date-popup-title">Fecha inicio</span>
                <span class="date-popup-close" onclick="closeDatePicker('start')">√ó</span>
              </div>
              <div class="year-grid" id="startYearGrid"></div>
              <div class="month-grid" id="startMonthGrid"></div>
              <div class="day-grid" id="startDayGrid"></div>
            </div>
          </div>
          
          <div class="date-picker-container">
            <input type="text" class="date-input" id="endDateDisplay" placeholder="Hasta..." readonly onclick="openDatePicker('end')">
            <div class="date-popup" id="endDatePopup">
              <div class="date-popup-header">
                <span class="date-popup-title">Fecha fin</span>
                <span class="date-popup-close" onclick="closeDatePicker('end')">√ó</span>
              </div>
              <div class="year-grid" id="endYearGrid"></div>
              <div class="month-grid" id="endMonthGrid"></div>
              <div class="day-grid" id="endDayGrid"></div>
            </div>
          </div>
          
          <input type="hidden" id="startDate" />
          <input type="hidden" id="endDate" />
          <button id="applyFiltersBtn" style="margin-top:0.4rem;">Aplicar filtros</button>
          <button id="resetFiltersBtn" class="secondary">Limpiar filtros</button>
        </div>
      </div>

      <!-- KPIs -->
      <div class="kpi-grid">
        <div class="kpi">
          <label>% Operaci√≥n global</label>
          <div class="kpi-value" id="kpiOperacion">-</div>
          <div class="kpi-sub" id="kpiOperacionSub"></div>
        </div>
        <div class="kpi">
          <label>Veh√≠culos programados / operativos</label>
          <div class="kpi-value" id="kpiProgramadosOperativos">-</div>
          <div class="kpi-sub">Suma en el rango filtrado</div>
        </div>
        <div class="kpi">
          <label>Placas √∫nicas</label>
          <div class="kpi-value" id="kpiPlacas">-</div>
          <div class="kpi-sub" id="kpiPlacasSub"></div>
        </div>
        <div class="kpi">
          <label>Rango de fechas</label>
          <div class="kpi-value" id="kpiRangoFechas">-</div>
          <div class="kpi-sub">Seg√∫n filtros aplicados</div>
        </div>
        <div class="kpi">
          <label>D√≠as por estado</label>
          <div class="kpi-value" id="kpiDiasEstado">-</div>
          <div class="kpi-sub" id="kpiDiasEstadoSub">Suma de d√≠as en taller</div>
        </div>
      </div>
    </div>

    <!-- Gr√°ficas -->
    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">% Operaci√≥n diario</div>
        <div id="chart_operacion_diaria" class="chart"></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">% Operaci√≥n por sede</div>
        <div id="chart_operacion_sede" class="chart"></div>
      </div>
    </div>

    <div class="chart-card full-width-chart">
      <div class="chart-title">Distribuci√≥n por estado de veh√≠culo & Top 10 d√≠as en taller</div>
      <div style="display:grid; grid-template-columns: minmax(0, 1fr) minmax(0, 1.4fr); gap:0.8rem;">
        <div id="chart_estado" class="chart"></div>
        <div id="chart_taller" class="chart"></div>
      </div>
    </div>

    <!-- Tabla detalle -->
    <div class="table-container">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.4rem;">
        <strong>Detalle de registros filtrados</strong>
        <span id="tableInfo" style="font-size:0.8rem; color:#666;"></span>
      </div>
      <table id="detailTable">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    let rawData = [];
    let filteredData = [];
    let chartFilter = { type: null, value: null }; // Filtro adicional desde gr√°ficas
    let sortState = { column: null, direction: 'asc' }; // Estado de ordenamiento de tabla
    const DATE_COL = "Fecha ejecucion";
    const SEDE_COL = "Sede";
    const ESTADO_COL = "Estado Vehiculo";
    const PROGRAMADOS_COL = "Vehiculos programados";
    const OPERATIVOS_COL = "Vehiculos operativos";
    const DIAS_TALLER_COL = "Dias en taller";
    const PLACA_COL = "placa";

    const detailColumns = [
      DATE_COL,
      PLACA_COL,
      "Tipo vehiculo",
      SEDE_COL,
      ESTADO_COL,
      "Brigada",
      "Conductor",
      "Contrato",
      PROGRAMADOS_COL,
      OPERATIVOS_COL,
      DIAS_TALLER_COL,
      "Motivo de inoperatividad"
    ];

    const statusEl = document.getElementById("status");
    const sedeFilterEl = document.getElementById("sedeFilter");
    const estadoFilterEl = document.getElementById("estadoFilter");
    const placaFilterEl = document.getElementById("placaFilter");
    const startDateEl = document.getElementById("startDate");
    const endDateEl = document.getElementById("endDate");
    const startDateDisplayEl = document.getElementById("startDateDisplay");
    const endDateDisplayEl = document.getElementById("endDateDisplay");
    
    const kpiOperacionEl = document.getElementById("kpiOperacion");
    const kpiOperacionSubEl = document.getElementById("kpiOperacionSub");
    const kpiProgOperEl = document.getElementById("kpiProgramadosOperativos");
    const kpiPlacasEl = document.getElementById("kpiPlacas");
    const kpiPlacasSubEl = document.getElementById("kpiPlacasSub");
    const kpiRangoFechasEl = document.getElementById("kpiRangoFechas");
    const kpiDiasEstadoEl = document.getElementById("kpiDiasEstado");
    const kpiDiasEstadoSubEl = document.getElementById("kpiDiasEstadoSub");
    const tableInfoEl = document.getElementById("tableInfo");
    const detailTableHead = document.querySelector("#detailTable thead");
    const detailTableBody = document.querySelector("#detailTable tbody");

    document.getElementById("fileInput").addEventListener("change", handleFile);
    document.getElementById("applyFiltersBtn").addEventListener("click", applyFilters);
    document.getElementById("resetFiltersBtn").addEventListener("click", resetFilters);
    
    // Eventos para filtrado autom√°tico y actualizar botones
    sedeFilterEl.addEventListener("change", function() {
      onSedeChange();
      updateToggleButton('sedeFilter', 'sedeFilterBtn');
    });
    estadoFilterEl.addEventListener("change", function() {
      onEstadoChange();
      updateToggleButton('estadoFilter', 'estadoFilterBtn');
    });
    placaFilterEl.addEventListener("change", function() {
      onPlacaChange();
      updateToggleButton('placaFilter', 'placaFilterBtn');
    });
    
    // Cargar datos guardados al iniciar (despu√©s de que todo est√© listo)
    // Verificar si el documento ya est√° listo o esperar el evento
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', function() {
        setTimeout(loadDataFromStorage, 100);
      });
    } else {
      // El DOM ya est√° listo, ejecutar directamente
      setTimeout(loadDataFromStorage, 100);
    }
    
    // Nombres de meses
    const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
    const monthNamesFull = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
    
    let datePickerState = {
      start: { year: null, month: null, day: null },
      end: { year: null, month: null, day: null },
      minYear: 2020,
      maxYear: 2025
    };
    
    function initDateSelectors(minDate, maxDate) {
      datePickerState.minYear = minDate.getFullYear();
      datePickerState.maxYear = maxDate.getFullYear();
      
      // Inicializar cuadr√≠culas de a√±os
      ['start', 'end'].forEach(prefix => {
        renderYearGrid(prefix);
      });
      
      // Establecer valores iniciales
      setDatePickerValue('start', minDate);
      setDatePickerValue('end', maxDate);
    }
    
    function renderYearGrid(prefix) {
      const yearGrid = document.getElementById(prefix + 'YearGrid');
      yearGrid.innerHTML = '';
      
      for (let y = datePickerState.minYear; y <= datePickerState.maxYear; y++) {
        const btn = document.createElement('div');
        btn.className = 'year-btn';
        btn.textContent = y;
        btn.dataset.year = y;
        if (datePickerState[prefix].year === y) {
          btn.classList.add('selected');
        }
        btn.onclick = () => selectYear(prefix, y);
        yearGrid.appendChild(btn);
      }
    }
    
    function selectYear(prefix, year) {
      datePickerState[prefix].year = year;
      
      // Actualizar selecci√≥n visual
      const yearGrid = document.getElementById(prefix + 'YearGrid');
      yearGrid.querySelectorAll('.year-btn').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.dataset.year) === year);
      });
      
      // Mostrar meses
      showMonths(prefix);
    }
    
    function setDatePickerValue(prefix, date) {
      datePickerState[prefix] = {
        year: date.getFullYear(),
        month: date.getMonth(),
        day: date.getDate()
      };
      
      // Actualizar selecci√≥n visual en cuadr√≠cula de a√±os
      const yearGrid = document.getElementById(prefix + 'YearGrid');
      if (yearGrid) {
        yearGrid.querySelectorAll('.year-btn').forEach(btn => {
          btn.classList.toggle('selected', parseInt(btn.dataset.year) === date.getFullYear());
        });
      }
      
      updateDateDisplay(prefix);
      syncHiddenDates();
    }
    
    function openDatePicker(prefix) {
      // Cerrar el otro popup si est√° abierto
      const otherPrefix = prefix === 'start' ? 'end' : 'start';
      document.getElementById(otherPrefix + 'DatePopup').classList.remove('active');
      
      const popup = document.getElementById(prefix + 'DatePopup');
      popup.classList.add('active');
      
      // Asegurar que el a√±o est√© seleccionado
      if (!datePickerState[prefix].year) {
        datePickerState[prefix].year = datePickerState.minYear || new Date().getFullYear();
      }
      
      // Actualizar selecci√≥n visual en cuadr√≠cula de a√±os
      const yearGrid = document.getElementById(prefix + 'YearGrid');
      if (yearGrid) {
        yearGrid.querySelectorAll('.year-btn').forEach(btn => {
          btn.classList.toggle('selected', parseInt(btn.dataset.year) === datePickerState[prefix].year);
        });
      }
      
      showMonths(prefix);
    }
    
    function closeDatePicker(prefix) {
      document.getElementById(prefix + 'DatePopup').classList.remove('active');
    }
    
    function showMonths(prefix) {
      const monthGrid = document.getElementById(prefix + 'MonthGrid');
      const dayGrid = document.getElementById(prefix + 'DayGrid');
      
      let year = datePickerState[prefix].year;
      if (!year) {
        year = datePickerState.minYear || new Date().getFullYear();
        datePickerState[prefix].year = year;
      }
      
      monthGrid.innerHTML = '';
      dayGrid.innerHTML = '';
      
      monthNames.forEach((name, idx) => {
        const btn = document.createElement('div');
        btn.className = 'month-btn';
        if (datePickerState[prefix].month === idx) {
          btn.classList.add('selected');
        }
        btn.textContent = name;
        btn.onclick = () => selectMonth(prefix, idx);
        monthGrid.appendChild(btn);
      });
      
      // Si ya hay un mes seleccionado, mostrar los d√≠as
      if (datePickerState[prefix].month !== null) {
        showDays(prefix);
      }
    }
    
    function selectMonth(prefix, month) {
      datePickerState[prefix].month = month;
      showDays(prefix);
    }
    
    function showDays(prefix) {
      const monthGrid = document.getElementById(prefix + 'MonthGrid');
      const dayGrid = document.getElementById(prefix + 'DayGrid');
      const year = datePickerState[prefix].year;
      const month = datePickerState[prefix].month;
      
      // Actualizar selecci√≥n visual del mes
      monthGrid.querySelectorAll('.month-btn').forEach((btn, idx) => {
        btn.classList.toggle('selected', idx === month);
      });
      
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      
      dayGrid.innerHTML = '';
      for (let d = 1; d <= daysInMonth; d++) {
        const btn = document.createElement('div');
        btn.className = 'day-btn';
        if (datePickerState[prefix].day === d) {
          btn.classList.add('selected');
        }
        btn.textContent = d;
        btn.onclick = () => selectDay(prefix, d);
        dayGrid.appendChild(btn);
      }
    }
    
    function selectDay(prefix, day) {
      datePickerState[prefix].day = day;
      updateDateDisplay(prefix);
      closeDatePicker(prefix);
      syncHiddenDates();
      onDateChange();
    }
    
    function updateDateDisplay(prefix) {
      const state = datePickerState[prefix];
      const displayEl = document.getElementById(prefix + 'DateDisplay');
      if (state.year && state.month !== null && state.day) {
        displayEl.value = `${state.day} ${monthNames[state.month]} ${state.year}`;
      }
    }
    
    function syncHiddenDates() {
      const start = datePickerState.start;
      const end = datePickerState.end;
      
      if (start.year && start.month !== null && start.day) {
        startDateEl.value = formatDateISO(new Date(start.year, start.month, start.day));
      }
      if (end.year && end.month !== null && end.day) {
        endDateEl.value = formatDateISO(new Date(end.year, end.month, end.day));
      }
    }
    
    // Cerrar popups al hacer clic fuera
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.date-picker-container')) {
        closeDatePicker('start');
        closeDatePicker('end');
      }
    });

    // Funciones para persistencia de datos usando IndexedDB (soporta archivos grandes)
    const DB_NAME = 'hesego_db';
    const DB_VERSION = 1;
    const STORE_NAME = 'excel_data';
    let isLoadingFilters = false; // Bandera para evitar guardar mientras se cargan filtros
    
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
        };
      });
    }
    
    async function saveDataToStorage(data, fileName) {
      try {
        // Preparar datos para guardar (sin objetos Date)
        const dataToSave = data.map(row => {
          const newRow = { ...row };
          delete newRow.__date;
          return newRow;
        });
        
        const db = await openDatabase();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        // Guardar datos
        store.put({
          id: 'main_data',
          data: dataToSave,
          fileName: fileName,
          savedAt: new Date().toISOString(),
          recordCount: data.length
        });
        
        transaction.oncomplete = () => {
          console.log(`‚úÖ Datos guardados: ${data.length} registros`);
          db.close();
        };
        
        transaction.onerror = () => {
          console.warn('Error guardando datos:', transaction.error);
          db.close();
        };
        
      } catch (e) {
        console.warn('No se pudo guardar en IndexedDB:', e.message);
      }
    }
    
    // Guardar filtros seleccionados
    async function saveFiltersToStorage() {
      try {
        const filters = {
          id: 'filters',
          sedes: getSelectedOptions(sedeFilterEl),
          estados: getSelectedOptions(estadoFilterEl),
          placas: getSelectedOptions(placaFilterEl),
          startDate: startDateEl.value,
          endDate: endDateEl.value,
          datePickerState: JSON.parse(JSON.stringify(datePickerState)) // Clonar objeto
        };
        
        console.log('üíæ Guardando filtros:', filters);
        
        const db = await openDatabase();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(filters);
        
        request.onsuccess = () => {
          console.log('‚úÖ Filtros guardados correctamente');
        };
        
        request.onerror = () => {
          console.warn('‚ùå Error en request de filtros:', request.error);
        };
        
        transaction.oncomplete = () => {
          console.log('‚úÖ Transacci√≥n de filtros completada');
          db.close();
        };
        
        transaction.onerror = () => {
          console.warn('‚ùå Error en transacci√≥n de filtros:', transaction.error);
          db.close();
        };
      } catch (e) {
        console.warn('Error guardando filtros:', e.message);
      }
    }
    
    // Restaurar filtros guardados
    async function loadFiltersFromStorage() {
      try {
        console.log('üîç Buscando filtros guardados...');
        const db = await openDatabase();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get('filters');
        
        request.onsuccess = () => {
          const filters = request.result;
          db.close();
          
          console.log('üì¶ Filtros encontrados:', filters);
          
          if (filters) {
            isLoadingFilters = true; // Evitar guardar mientras restauramos
            
            // Restaurar selecci√≥n de sedes
            if (filters.sedes && filters.sedes.length > 0) {
              console.log('Restaurando sedes:', filters.sedes);
              Array.from(sedeFilterEl.options).forEach(opt => {
                opt.selected = filters.sedes.includes(opt.value);
              });
            }
            
            // Restaurar selecci√≥n de estados
            if (filters.estados && filters.estados.length > 0) {
              console.log('Restaurando estados:', filters.estados);
              Array.from(estadoFilterEl.options).forEach(opt => {
                opt.selected = filters.estados.includes(opt.value);
              });
            }
            
            // Restaurar selecci√≥n de placas
            if (filters.placas && filters.placas.length > 0) {
              console.log('Restaurando placas:', filters.placas);
              Array.from(placaFilterEl.options).forEach(opt => {
                opt.selected = filters.placas.includes(opt.value);
              });
            }
            
            // Restaurar fechas
            if (filters.startDate) {
              console.log('Restaurando fecha inicio:', filters.startDate);
              startDateEl.value = filters.startDate;
            }
            if (filters.endDate) {
              console.log('Restaurando fecha fin:', filters.endDate);
              endDateEl.value = filters.endDate;
            }
            
            // Restaurar estado del date picker
            if (filters.datePickerState) {
              datePickerState.start = filters.datePickerState.start || datePickerState.start;
              datePickerState.end = filters.datePickerState.end || datePickerState.end;
              updateDateDisplay('start');
              updateDateDisplay('end');
            }
            
            // Actualizar texto de los botones seg√∫n la selecci√≥n restaurada
            updateToggleButton('sedeFilter', 'sedeFilterBtn');
            updateToggleButton('estadoFilter', 'estadoFilterBtn');
            updateToggleButton('placaFilter', 'placaFilterBtn');
            
            console.log('‚úÖ Filtros restaurados completamente');
            applyFilters();
            
            isLoadingFilters = false; // Permitir guardar de nuevo
          } else {
            console.log('‚ÑπÔ∏è No hay filtros guardados, aplicando por defecto');
            // No hay filtros guardados, aplicar filtros por defecto
            applyFilters();
          }
        };
        
        request.onerror = () => {
          console.warn('‚ùå Error leyendo filtros:', request.error);
          db.close();
          applyFilters();
        };
      } catch (e) {
        console.warn('Error cargando filtros:', e.message);
        isLoadingFilters = false;
        applyFilters();
      }
    }
    
    async function loadDataFromStorage() {
      try {
        console.log('Buscando datos guardados...');
        
        const db = await openDatabase();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get('main_data');
        
        request.onsuccess = () => {
          const result = request.result;
          db.close();
          
          if (result && result.data) {
            rawData = result.data;
            
            // Recalcular fechas
            rawData.forEach(row => {
              const d = parseDate(row[DATE_COL]);
              row.__date = d;
              row.__dateStr = d ? formatDateISO(d) : null;
            });
            
            console.log(`‚úÖ Datos restaurados: ${rawData.length} registros`);
            setStatus(`Datos restaurados: ${rawData.length} registros. Archivo: "${result.fileName || 'desconocido'}"`);
            
            initFilters();
            // Cargar filtros guardados despu√©s de inicializar
            loadFiltersFromStorage();
          } else {
            console.log('No hay datos guardados previamente');
          }
        };
        
        request.onerror = () => {
          console.warn('Error leyendo datos:', request.error);
          db.close();
        };
        
      } catch (e) {
        console.warn('No se pudo cargar desde IndexedDB:', e.message);
      }
    }

    function setStatus(msg) {
      statusEl.textContent = msg || "";
    }

    function excelDateToJSDate(serial) {
      // Convierte n√∫mero Excel a Date
      const utc_days = Math.floor(serial - 25569);
      const utc_value = utc_days * 86400;
      const date_info = new Date(utc_value * 1000);
      return new Date(date_info.getFullYear(), date_info.getMonth(), date_info.getDate());
    }

    function parseDate(value) {
      if (!value) return null;
      if (value instanceof Date) return value;
      if (typeof value === "number") {
        return excelDateToJSDate(value);
      }
      if (typeof value === "string") {
        // Intento directo
        const d = new Date(value);
        if (!isNaN(d.getTime())) return d;
      }
      return null;
    }

    function formatDateISO(d) {
      if (!d) return "";
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function handleFile(evt) {
      const file = evt.target.files[0];
      if (!file) {
        setStatus("No se seleccion√≥ archivo.");
        return;
      }
      setStatus("Leyendo archivo...");
      const reader = new FileReader();
      reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: "array" });

        // Buscar hoja "operatividad diaria" (o similar)
        let sheetName = workbook.SheetNames.find(n =>
          n.toLowerCase().includes("operatividad")
        );
        if (!sheetName) {
          sheetName = workbook.SheetNames[0];
        }

        const sheet = workbook.Sheets[sheetName];
        rawData = XLSX.utils.sheet_to_json(sheet, { defval: null });

        if (!rawData.length) {
          setStatus("La hoja est√° vac√≠a.");
          return;
        }

        // Normalizar columna de fecha
        rawData.forEach(row => {
          const d = parseDate(row[DATE_COL]);
          row.__date = d; // guardamos la Date calculada
          row.__dateStr = d ? formatDateISO(d) : null;
        });

        // Guardar en localStorage para persistencia
        saveDataToStorage(rawData, file.name);

        setStatus(`Archivo cargado. Registros: ${rawData.length}. Hoja: "${sheetName}".`);

        initFilters();
        applyFilters();
      };
      reader.onerror = function() {
        setStatus("Error leyendo el archivo.");
      };
      reader.readAsArrayBuffer(file);
    }

    function getSelectedOptions(selectEl) {
      return Array.from(selectEl.options)
        .filter(opt => opt.selected)
        .map(opt => opt.value);
    }

    function initFilters() {
      // llenar Sede
      const sedes = Array.from(
        new Set(rawData.map(r => r[SEDE_COL]).filter(Boolean))
      ).sort();
      sedeFilterEl.innerHTML = "";
      sedes.forEach(sede => {
        const opt = document.createElement("option");
        opt.value = sede;
        opt.textContent = sede;
        sedeFilterEl.appendChild(opt);
      });

      // llenar Estado
      const estados = Array.from(
        new Set(rawData.map(r => r[ESTADO_COL]).filter(Boolean))
      ).sort();
      estadoFilterEl.innerHTML = "";
      estados.forEach(est => {
        const opt = document.createElement("option");
        opt.value = est;
        opt.textContent = est;
        estadoFilterEl.appendChild(opt);
      });

      // llenar Placas
      updatePlacaFilter();

      // rango de fechas global
      const validDates = rawData
        .map(r => r.__date)
        .filter(d => d instanceof Date && !isNaN(d));
      if (validDates.length) {
        const minD = new Date(Math.min.apply(null, validDates));
        const maxD = new Date(Math.max.apply(null, validDates));
        initDateSelectors(minD, maxD);
      }
    }

    function toggleSelectAll(selectId, buttonId) {
      const selectEl = document.getElementById(selectId);
      const buttonEl = document.getElementById(buttonId);
      
      // Verificar si hay opciones visibles seleccionadas
      const visibleOptions = Array.from(selectEl.options).filter(opt => opt.style.display !== 'none');
      const allSelected = visibleOptions.length > 0 && visibleOptions.every(opt => opt.selected);
      
      if (allSelected) {
        // Deseleccionar todo
        visibleOptions.forEach(opt => opt.selected = false);
        buttonEl.textContent = 'Seleccionar todo';
      } else {
        // Seleccionar todo
        visibleOptions.forEach(opt => opt.selected = true);
        buttonEl.textContent = 'Deseleccionar todo';
      }
      
      // Disparar cambio autom√°tico
      selectEl.dispatchEvent(new Event('change'));
    }
    
    // Actualizar texto del bot√≥n seg√∫n selecci√≥n actual
    function updateToggleButton(selectId, buttonId) {
      const selectEl = document.getElementById(selectId);
      const buttonEl = document.getElementById(buttonId);
      if (!buttonEl) return;
      
      const visibleOptions = Array.from(selectEl.options).filter(opt => opt.style.display !== 'none');
      const allSelected = visibleOptions.length > 0 && visibleOptions.every(opt => opt.selected);
      
      buttonEl.textContent = allSelected ? 'Deseleccionar todo' : 'Seleccionar todo';
    }

    function filterSelect(selectId, searchText) {
      const selectEl = document.getElementById(selectId);
      const search = searchText.toLowerCase().trim();
      
      Array.from(selectEl.options).forEach(opt => {
        const text = opt.textContent.toLowerCase();
        if (search === '' || text.includes(search)) {
          opt.style.display = '';
        } else {
          opt.style.display = 'none';
        }
      });
    }

    function onDateChange() {
      if (!rawData.length) return;
      syncHiddenDates();
      updatePlacaFilter();
      updateEstadoFilter();
      applyFilters();
    }

    function onSedeChange() {
      if (!rawData.length) return;
      updatePlacaFilterBySedeAndEstado();
      updateEstadoFilterBySede();
      applyFilters();
    }

    function onEstadoChange() {
      if (!rawData.length) return;
      updatePlacaFilterBySedeAndEstado();
      applyFilters();
    }

    function onPlacaChange() {
      if (!rawData.length) return;
      
      const selectedPlacas = getSelectedOptions(placaFilterEl);
      
      // Si hay placas seleccionadas, marcar las sedes y estados correspondientes
      if (selectedPlacas.length > 0) {
        // Encontrar sedes y estados de las placas seleccionadas
        const sedesDeplacas = new Set();
        const estadosDePlacas = new Set();
        
        rawData.forEach(row => {
          if (selectedPlacas.includes(String(row[PLACA_COL]))) {
            if (row[SEDE_COL]) sedesDeplacas.add(String(row[SEDE_COL]));
            if (row[ESTADO_COL]) estadosDePlacas.add(String(row[ESTADO_COL]));
          }
        });
        
        // Deseleccionar todo primero
        Array.from(sedeFilterEl.options).forEach(opt => opt.selected = false);
        Array.from(estadoFilterEl.options).forEach(opt => opt.selected = false);
        
        // Seleccionar las sedes correspondientes
        let primeraSede = null;
        Array.from(sedeFilterEl.options).forEach(opt => {
          if (sedesDeplacas.has(opt.value)) {
            opt.selected = true;
            if (!primeraSede) primeraSede = opt;
          }
        });
        
        // Seleccionar los estados correspondientes
        let primerEstado = null;
        Array.from(estadoFilterEl.options).forEach(opt => {
          if (estadosDePlacas.has(opt.value)) {
            opt.selected = true;
            if (!primerEstado) primerEstado = opt;
          }
        });
        
        // Hacer scroll para mostrar la primera opci√≥n seleccionada
        if (primeraSede) {
          primeraSede.scrollIntoView({ block: 'nearest' });
        }
        if (primerEstado) {
          primerEstado.scrollIntoView({ block: 'nearest' });
        }
      }
      
      applyFilters();
    }

    function updateEstadoFilterBySede() {
      const selectedSedes = getSelectedOptions(sedeFilterEl);
      const startFilter = startDateEl.value ? new Date(startDateEl.value) : null;
      const endFilter = endDateEl.value ? new Date(endDateEl.value) : null;
      
      let dataFiltrada = rawData;
      
      // Filtrar por fecha
      if (startFilter || endFilter) {
        dataFiltrada = dataFiltrada.filter(row => {
          const d = row.__date;
          if (!(d instanceof Date) || isNaN(d)) return false;
          if (startFilter && d < startFilter) return false;
          if (endFilter && d > endFilter) return false;
          return true;
        });
      }
      
      // Filtrar por sede si hay selecci√≥n
      if (selectedSedes.length > 0) {
        dataFiltrada = dataFiltrada.filter(row => selectedSedes.includes(String(row[SEDE_COL])));
      }
      
      const estadosDisponibles = Array.from(
        new Set(dataFiltrada.map(r => r[ESTADO_COL]).filter(Boolean))
      ).sort();
      
      const previousSelection = getSelectedOptions(estadoFilterEl);
      estadoFilterEl.innerHTML = "";
      estadosDisponibles.forEach(est => {
        const opt = document.createElement("option");
        opt.value = est;
        opt.textContent = est;
        opt.selected = previousSelection.includes(est);
        estadoFilterEl.appendChild(opt);
      });
    }

    function updateEstadoFilterByPlaca(selectedPlacas) {
      const startFilter = startDateEl.value ? new Date(startDateEl.value) : null;
      const endFilter = endDateEl.value ? new Date(endDateEl.value) : null;
      
      let dataFiltrada = rawData;
      
      // Filtrar por fecha
      if (startFilter || endFilter) {
        dataFiltrada = dataFiltrada.filter(row => {
          const d = row.__date;
          if (!(d instanceof Date) || isNaN(d)) return false;
          if (startFilter && d < startFilter) return false;
          if (endFilter && d > endFilter) return false;
          return true;
        });
      }
      
      // Filtrar por placas seleccionadas
      if (selectedPlacas.length > 0) {
        dataFiltrada = dataFiltrada.filter(row => selectedPlacas.includes(String(row[PLACA_COL])));
      }
      
      const estadosDisponibles = Array.from(
        new Set(dataFiltrada.map(r => r[ESTADO_COL]).filter(Boolean))
      ).sort();
      
      // Seleccionar todos los estados de las placas autom√°ticamente
      estadoFilterEl.innerHTML = "";
      estadosDisponibles.forEach(est => {
        const opt = document.createElement("option");
        opt.value = est;
        opt.textContent = est;
        opt.selected = true; // Seleccionar todos autom√°ticamente
        estadoFilterEl.appendChild(opt);
      });
    }

    function updateEstadoFilter() {
      const startFilter = startDateEl.value ? new Date(startDateEl.value) : null;
      const endFilter = endDateEl.value ? new Date(endDateEl.value) : null;
      
      let dataFiltrada = rawData;
      
      if (startFilter || endFilter) {
        dataFiltrada = dataFiltrada.filter(row => {
          const d = row.__date;
          if (!(d instanceof Date) || isNaN(d)) return false;
          if (startFilter && d < startFilter) return false;
          if (endFilter && d > endFilter) return false;
          return true;
        });
      }
      
      const estadosDisponibles = Array.from(
        new Set(dataFiltrada.map(r => r[ESTADO_COL]).filter(Boolean))
      ).sort();
      
      const previousSelection = getSelectedOptions(estadoFilterEl);
      estadoFilterEl.innerHTML = "";
      estadosDisponibles.forEach(est => {
        const opt = document.createElement("option");
        opt.value = est;
        opt.textContent = est;
        opt.selected = previousSelection.includes(est);
        estadoFilterEl.appendChild(opt);
      });
    }

    function updatePlacaFilterBySede() {
      updatePlacaFilterBySedeAndEstado();
    }

    function updatePlacaFilterBySedeAndEstado() {
      const selectedSedes = getSelectedOptions(sedeFilterEl);
      const selectedEstados = getSelectedOptions(estadoFilterEl);
      const startFilter = startDateEl.value ? new Date(startDateEl.value) : null;
      const endFilter = endDateEl.value ? new Date(endDateEl.value) : null;
      
      let dataFiltrada = rawData;
      
      // Filtrar por fecha
      if (startFilter || endFilter) {
        dataFiltrada = dataFiltrada.filter(row => {
          const d = row.__date;
          if (!(d instanceof Date) || isNaN(d)) return false;
          if (startFilter && d < startFilter) return false;
          if (endFilter && d > endFilter) return false;
          return true;
        });
      }
      
      // Filtrar por sede si hay selecci√≥n
      if (selectedSedes.length > 0) {
        dataFiltrada = dataFiltrada.filter(row => selectedSedes.includes(String(row[SEDE_COL])));
      }
      
      // Filtrar por estado si hay selecci√≥n
      if (selectedEstados.length > 0) {
        dataFiltrada = dataFiltrada.filter(row => selectedEstados.includes(String(row[ESTADO_COL])));
      }
      
      const placasDisponibles = Array.from(
        new Set(dataFiltrada.map(r => r[PLACA_COL]).filter(Boolean))
      ).sort();
      
      const previousSelection = getSelectedOptions(placaFilterEl);
      placaFilterEl.innerHTML = "";
      placasDisponibles.forEach(placa => {
        const opt = document.createElement("option");
        opt.value = placa;
        opt.textContent = placa;
        opt.selected = previousSelection.includes(placa);
        placaFilterEl.appendChild(opt);
      });
    }

    // Mantener la funci√≥n original por compatibilidad
    function updatePlacaFilterBySedeOriginal() {
      const selectedSedes = getSelectedOptions(sedeFilterEl);
      const startFilter = startDateEl.value ? new Date(startDateEl.value) : null;
      const endFilter = endDateEl.value ? new Date(endDateEl.value) : null;
      
      let dataFiltrada = rawData;
      
      // Filtrar por fecha
      if (startFilter || endFilter) {
        dataFiltrada = dataFiltrada.filter(row => {
          const d = row.__date;
          if (!(d instanceof Date) || isNaN(d)) return false;
          if (startFilter && d < startFilter) return false;
          if (endFilter && d > endFilter) return false;
          return true;
        });
      }
      
      // Filtrar por sede si hay selecci√≥n
      if (selectedSedes.length > 0) {
        dataFiltrada = dataFiltrada.filter(row => selectedSedes.includes(String(row[SEDE_COL])));
      }
      
      const placasDisponibles = Array.from(
        new Set(dataFiltrada.map(r => r[PLACA_COL]).filter(Boolean))
      ).sort();
      
      const previousSelection = getSelectedOptions(placaFilterEl);
      placaFilterEl.innerHTML = "";
      placasDisponibles.forEach(placa => {
        const opt = document.createElement("option");
        opt.value = placa;
        opt.textContent = placa;
        opt.selected = previousSelection.includes(placa);
        placaFilterEl.appendChild(opt);
      });
    }

    function updatePlacaFilter() {
      // Obtener rango de fechas actual
      const startFilter = startDateEl.value ? new Date(startDateEl.value) : null;
      const endFilter = endDateEl.value ? new Date(endDateEl.value) : null;

      // Filtrar placas por rango de fechas
      const placasEnRango = rawData.filter(row => {
        if (startFilter || endFilter) {
          const d = row.__date;
          if (!(d instanceof Date) || isNaN(d)) return false;
          if (startFilter && d < startFilter) return false;
          if (endFilter && d > endFilter) return false;
        }
        return true;
      });

      const placas = Array.from(
        new Set(placasEnRango.map(r => r[PLACA_COL]).filter(Boolean))
      ).sort();

      const previousSelection = getSelectedOptions(placaFilterEl);
      placaFilterEl.innerHTML = '';
      placas.forEach(placa => {
        const opt = document.createElement("option");
        opt.value = placa;
        opt.textContent = placa;
        opt.selected = previousSelection.includes(placa);
        placaFilterEl.appendChild(opt);
      });
    }

    function applyFilters() {
      if (!rawData.length) return;

      const selectedSedes = getSelectedOptions(sedeFilterEl);
      const selectedEstados = getSelectedOptions(estadoFilterEl);
      const selectedPlacas = getSelectedOptions(placaFilterEl);
      const startFilter = startDateEl.value ? new Date(startDateEl.value) : null;
      const endFilter = endDateEl.value ? new Date(endDateEl.value) : null;

      filteredData = rawData.filter(row => {
        // fecha
        if (startFilter || endFilter) {
          const d = row.__date;
          if (!(d instanceof Date) || isNaN(d)) {
            return false;
          }
          if (startFilter && d < startFilter) return false;
          if (endFilter && d > endFilter) return false;
        }
        // sede
        if (selectedSedes.length > 0) {
          const sede = row[SEDE_COL];
          if (!selectedSedes.includes(String(sede))) return false;
        }
        // estado
        if (selectedEstados.length > 0) {
          const est = row[ESTADO_COL];
          if (!selectedEstados.includes(String(est))) return false;
        }
        // placa
        if (selectedPlacas.length > 0) {
          const placa = row[PLACA_COL];
          if (!selectedPlacas.includes(String(placa))) return false;
        }
        return true;
      });

      setStatus(`Registros filtrados: ${filteredData.length}`);
      updateKPIs();
      drawCharts();
      renderTable();
      
      // Guardar filtros (solo si no estamos en proceso de carga)
      if (!isLoadingFilters) {
        saveFiltersToStorage();
      }
    }

    function resetFilters() {
      if (!rawData.length) return;
      // borrar selecci√≥n m√∫ltiple
      Array.from(sedeFilterEl.options).forEach(o => (o.selected = false));
      Array.from(estadoFilterEl.options).forEach(o => (o.selected = false));
      Array.from(placaFilterEl.options).forEach(o => (o.selected = false));

      const validDates = rawData
        .map(r => r.__date)
        .filter(d => d instanceof Date && !isNaN(d));
      if (validDates.length) {
        const minD = new Date(Math.min.apply(null, validDates));
        const maxD = new Date(Math.max.apply(null, validDates));
        initDateSelectors(minD, maxD);
      }
      applyFilters();
      
      // Limpiar filtros guardados
      clearSavedFilters();
    }
    
    async function clearSavedFilters() {
      try {
        const db = await openDatabase();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        store.delete('filters');
        transaction.oncomplete = () => {
          console.log('‚úÖ Filtros guardados eliminados');
          db.close();
        };
      } catch (e) {
        console.warn('Error eliminando filtros:', e.message);
      }
    }

    function sumNumeric(arr, col) {
      return arr.reduce((acc, r) => {
        const val = parseFloat(r[col]);
        if (!isNaN(val)) return acc + val;
        return acc;
      }, 0);
    }

    function updateKPIs() {
      if (!filteredData.length) {
        kpiOperacionEl.textContent = "-";
        kpiOperacionSubEl.textContent = "";
        kpiProgOperEl.textContent = "-";
        kpiPlacasEl.textContent = "-";
        kpiPlacasSubEl.textContent = "";
        kpiRangoFechasEl.textContent = "-";
        kpiDiasEstadoEl.textContent = "-";
        kpiDiasEstadoSubEl.textContent = "";
        return;
      }

      const totalProg = sumNumeric(filteredData, PROGRAMADOS_COL);
      const totalOper = sumNumeric(filteredData, OPERATIVOS_COL);
      const pct = totalProg > 0 ? (totalOper / totalProg) * 100 : 0;

      kpiOperacionEl.textContent = pct.toFixed(1) + " %";
      kpiOperacionSubEl.textContent = `Operativos: ${totalOper.toFixed(0)} / Programados: ${totalProg.toFixed(0)}`;

      kpiProgOperEl.textContent = `${totalProg.toFixed(0)} / ${totalOper.toFixed(0)}`;

      const placas = new Set(
        filteredData.map(r => r[PLACA_COL]).filter(Boolean)
      );
      kpiPlacasEl.textContent = placas.size;
      const estados = new Set(
        filteredData.map(r => r[ESTADO_COL]).filter(Boolean)
      );
      kpiPlacasSubEl.textContent = `Estados: ${Array.from(estados).join(", ")}`;

      const validDates = filteredData
        .map(r => r.__date)
        .filter(d => d instanceof Date && !isNaN(d));
      if (validDates.length) {
        const minD = new Date(Math.min.apply(null, validDates));
        const maxD = new Date(Math.max.apply(null, validDates));
        kpiRangoFechasEl.textContent =
          formatDateISO(minD) + " ‚Üí " + formatDateISO(maxD);
      } else {
        kpiRangoFechasEl.textContent = "-";
      }

      // Calcular d√≠as por estado (contar registros por estado)
      const diasPorEstado = {};
      filteredData.forEach(r => {
        const estado = r[ESTADO_COL] || "Sin estado";
        if (!diasPorEstado[estado]) diasPorEstado[estado] = 0;
        diasPorEstado[estado] += 1; // Cada registro = 1 d√≠a
      });
      
      // Total de d√≠as (registros)
      const totalDias = filteredData.length;
      kpiDiasEstadoEl.textContent = totalDias + " d√≠as";
      
      // Mostrar desglose por estado
      const desglose = Object.entries(diasPorEstado)
        .sort((a, b) => b[1] - a[1]) // Ordenar por cantidad descendente
        .map(([estado, dias]) => `${estado}: ${dias}`)
        .join(" | ");
      kpiDiasEstadoSubEl.textContent = desglose || "Sin registros";
    }

    function drawCharts() {
      if (!filteredData.length) {
        Plotly.purge("chart_operacion_diaria");
        Plotly.purge("chart_operacion_sede");
        Plotly.purge("chart_estado");
        Plotly.purge("chart_taller");
        return;
      }

      drawOperacionDiaria();
      drawOperacionPorSede();
      drawEstadoPie();
      drawTopTaller();
    }

    function drawOperacionDiaria() {
      const map = {};
      filteredData.forEach(r => {
        const dateKey = r.__dateStr || "";
        if (!dateKey) return;
        if (!map[dateKey]) {
          map[dateKey] = { prog: 0, oper: 0 };
        }
        const p = parseFloat(r[PROGRAMADOS_COL]) || 0;
        const o = parseFloat(r[OPERATIVOS_COL]) || 0;
        map[dateKey].prog += p;
        map[dateKey].oper += o;
      });

      const dates = Object.keys(map).sort();
      const pctArr = dates.map(d => {
        const prog = map[d].prog;
        const oper = map[d].oper;
        return prog > 0 ? (oper / prog) * 100 : null;
      });

      const tracePct = {
        x: dates,
        y: pctArr,
        mode: "lines+markers",
        name: "% operaci√≥n",
        hovertemplate: "%{x}<br>% operaci√≥n: %{y:.1f}%<extra></extra>"
      };

      const layout = {
        margin: { t: 20, r: 10, b: 40, l: 45 },
        yaxis: {
          title: "% operaci√≥n",
          rangemode: "tozero"
        },
        xaxis: {
          type: "category",
          tickangle: -45
        }
      };

      Plotly.newPlot("chart_operacion_diaria", [tracePct], layout, { responsive: true });
    }

    function drawOperacionPorSede() {
      const map = {};
      filteredData.forEach(r => {
        const sede = r[SEDE_COL] || "Sin sede";
        if (!map[sede]) {
          map[sede] = { prog: 0, oper: 0 };
        }
        const p = parseFloat(r[PROGRAMADOS_COL]) || 0;
        const o = parseFloat(r[OPERATIVOS_COL]) || 0;
        map[sede].prog += p;
        map[sede].oper += o;
      });

      const sedes = Object.keys(map).sort();
      const pctArr = sedes.map(s => {
        const prog = map[s].prog;
        const oper = map[s].oper;
        return prog > 0 ? (oper / prog) * 100 : 0;
      });

      const trace = {
        x: sedes,
        y: pctArr,
        type: "bar",
        hovertemplate: "%{x}<br>% operaci√≥n: %{y:.1f}%<extra></extra>"
      };

      const layout = {
        margin: { t: 20, r: 10, b: 80, l: 45 },
        yaxis: {
          title: "% operaci√≥n",
          rangemode: "tozero"
        },
        xaxis: {
          tickangle: -40
        }
      };

      Plotly.newPlot("chart_operacion_sede", [trace], layout, { responsive: true });
    }

    function drawEstadoPie() {
      const map = {};
      filteredData.forEach(r => {
        const est = r[ESTADO_COL] || "Sin estado";
        if (!map[est]) map[est] = 0;
        map[est] += 1;
      });

      const labels = Object.keys(map);
      const values = labels.map(l => map[l]);

      const trace = {
        labels: labels,
        values: values,
        type: "pie",
        textinfo: "label+percent",
        hovertemplate: "%{label}<br>%{value} registros<br><i>Click para filtrar</i><extra></extra>"
      };

      const layout = {
        margin: { t: 20, r: 10, b: 10, l: 10 }
      };

      Plotly.newPlot("chart_estado", [trace], layout, { responsive: true });
      
      // Agregar evento de click
      document.getElementById("chart_estado").on('plotly_click', function(data) {
        if (data.points && data.points.length > 0) {
          const clickedEstado = data.points[0].label;
          if (chartFilter.type === 'estado' && chartFilter.value === clickedEstado) {
            // Si ya est√° filtrado por este estado, quitar filtro
            chartFilter = { type: null, value: null };
          } else {
            chartFilter = { type: 'estado', value: clickedEstado };
          }
          renderTableWithChartFilter();
        }
      });
    }

    function drawTopTaller() {
      const map = {};
      filteredData.forEach(r => {
        const placa = r[PLACA_COL] || "Sin placa";
        const dias = parseFloat(r[DIAS_TALLER_COL]) || 0;
        if (!map[placa]) map[placa] = 0;
        map[placa] += dias;
      });

      let entries = Object.entries(map);
      entries.sort((a, b) => b[1] - a[1]);
      entries = entries.slice(0, 10);

      const placas = entries.map(e => e[0]);
      const diasArr = entries.map(e => e[1]);

      const trace = {
        x: diasArr,
        y: placas,
        type: "bar",
        orientation: "h",
        hovertemplate: "Placa: %{y}<br>D√≠as taller: %{x:.0f}<br><i>Click para filtrar</i><extra></extra>"
      };

      const layout = {
        margin: { t: 20, r: 10, b: 40, l: 80 },
        xaxis: { title: "D√≠as en taller (suma)" }
      };

      Plotly.newPlot("chart_taller", [trace], layout, { responsive: true });
      
      // Agregar evento de click
      document.getElementById("chart_taller").on('plotly_click', function(data) {
        if (data.points && data.points.length > 0) {
          const clickedPlaca = data.points[0].y;
          if (chartFilter.type === 'placa' && chartFilter.value === clickedPlaca) {
            // Si ya est√° filtrado por esta placa, quitar filtro
            chartFilter = { type: null, value: null };
          } else {
            chartFilter = { type: 'placa', value: clickedPlaca };
          }
          renderTableWithChartFilter();
        }
      });
    }

    function renderTableWithChartFilter() {
      let dataToRender = filteredData;
      
      // Aplicar filtro de gr√°fica si existe
      if (chartFilter.type === 'estado' && chartFilter.value) {
        dataToRender = filteredData.filter(r => String(r[ESTADO_COL]) === chartFilter.value);
      } else if (chartFilter.type === 'placa' && chartFilter.value) {
        dataToRender = filteredData.filter(r => String(r[PLACA_COL]) === chartFilter.value);
      }
      
      renderTableData(dataToRender);
    }

    function renderTable() {
      // Limpiar filtro de gr√°fica al aplicar filtros principales
      chartFilter = { type: null, value: null };
      renderTableData(filteredData);
    }

    function renderTableData(dataToRender) {
      detailTableHead.innerHTML = "";
      detailTableBody.innerHTML = "";

      // Aplicar ordenamiento si est√° activo
      let sortedData = [...dataToRender];
      if (sortState.column) {
        sortedData.sort((a, b) => {
          let valA = a[sortState.column];
          let valB = b[sortState.column];
          
          // Usar fecha parseada para columna de fecha
          if (sortState.column === DATE_COL) {
            valA = a.__date;
            valB = b.__date;
          }
          
          // Manejar nulls/undefined
          if (valA == null && valB == null) return 0;
          if (valA == null) return 1;
          if (valB == null) return -1;
          
          // Comparar fechas
          if (valA instanceof Date && valB instanceof Date) {
            return sortState.direction === 'asc' ? valA - valB : valB - valA;
          }
          
          // Intentar comparar como n√∫meros
          const numA = parseFloat(valA);
          const numB = parseFloat(valB);
          if (!isNaN(numA) && !isNaN(numB)) {
            return sortState.direction === 'asc' ? numA - numB : numB - numA;
          }
          
          // Comparar como strings
          const strA = String(valA).toLowerCase();
          const strB = String(valB).toLowerCase();
          if (strA < strB) return sortState.direction === 'asc' ? -1 : 1;
          if (strA > strB) return sortState.direction === 'asc' ? 1 : -1;
          return 0;
        });
      }

      const theadRow = document.createElement("tr");
      detailColumns.forEach(col => {
        const th = document.createElement("th");
        th.innerHTML = col + '<span class="sort-icon"></span>';
        th.dataset.column = col;
        
        // Agregar clase de ordenamiento activo
        if (sortState.column === col) {
          th.classList.add(sortState.direction === 'asc' ? 'sort-asc' : 'sort-desc');
        }
        
        th.onclick = () => handleSort(col);
        theadRow.appendChild(th);
      });
      detailTableHead.appendChild(theadRow);

      const maxRows = 300;
      const rowsToShow = sortedData.slice(0, maxRows);

      // Si no hay datos, mostrar mensaje
      if (sortedData.length === 0) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = detailColumns.length;
        td.style.textAlign = "center";
        td.style.padding = "2rem";
        td.style.color = "#666";
        td.style.fontStyle = "italic";
        td.innerHTML = '<div style="font-size: 1.1rem; margin-bottom: 0.5rem;">üìÖ No hay registros para el rango de fechas seleccionado</div><div style="font-size: 0.85rem;">Intenta ajustar las fechas o limpiar los filtros</div>';
        tr.appendChild(td);
        detailTableBody.appendChild(tr);
        tableInfoEl.textContent = "Sin registros";
        return;
      }

      rowsToShow.forEach(r => {
        const tr = document.createElement("tr");
        detailColumns.forEach(col => {
          const td = document.createElement("td");
          let val = r[col];

          if (col === DATE_COL) {
            val = r.__date ? formatDateISO(r.__date) : "";
          }

          if (col === ESTADO_COL && val) {
            const span = document.createElement("span");
            span.className = "badge";
            span.textContent = val;
            td.appendChild(span);
          } else {
            td.textContent = val == null ? "" : String(val);
          }
          tr.appendChild(td);
        });
        detailTableBody.appendChild(tr);
      });

      const total = dataToRender.length;
      let filterInfo = '';
      if (chartFilter.type === 'estado') {
        filterInfo = ` | Filtro gr√°fica: Estado "${chartFilter.value}" (click de nuevo para quitar)`;
      } else if (chartFilter.type === 'placa') {
        filterInfo = ` | Filtro gr√°fica: Placa "${chartFilter.value}" (click de nuevo para quitar)`;
      }
      
      if (total > maxRows) {
        tableInfoEl.textContent = `Mostrando ${rowsToShow.length} de ${total} registros${filterInfo}`;
      } else {
        tableInfoEl.textContent = `Registros mostrados: ${total}${filterInfo}`;
      }
    }
    
    function handleSort(column) {
      if (sortState.column === column) {
        // Si ya est√° ordenando por esta columna, cambiar direcci√≥n
        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
      } else {
        // Nueva columna, empezar ascendente
        sortState.column = column;
        sortState.direction = 'asc';
      }
      
      // Re-renderizar tabla con el nuevo orden
      if (chartFilter.type) {
        renderTableWithChartFilter();
      } else {
        renderTableData(filteredData);
      }
    }
  </script>
</body>
</html>
